<?php

/**
 * Debugging tool which displays information about any PHP variable, class or exception.
 * Inspired in Krumo by mrasnika (http://krumo.sourceforge.net/)
 * @author Javier MarÃ­n (https://github.com/javiermarinros)
 */
abstract class Dump
{

    private static $_static_url = '/dump-static';
    private static $_special_paths = array();
    private static $_nesting_level = 5;

    public static function config($static_url = '/dump-static', $special_paths = array(), $nesting_level = 5)
    {
        if (func_num_args() == 0) {
            return [
                'static_url'    => self::$_static_url,
                'special_paths' => self::$_special_paths,
                'nesting_level' => self::$_nesting_level
            ];
        }

        self::$_static_url = $static_url;
        self::$_special_paths = $special_paths;
        self::$_nesting_level = $nesting_level;
    }

    private static function _load_helpers()
    {
        require_once dirname(__FILE__) . '/DumpRender.php';
    }

    /**
     * Display information about one or more PHP variables
     *
     * @param mixed $var
     */
    public static function show()
    {
        self::_load_helpers();

        $render = new DumpRender();
        $render->html = true;
        $render->show_caller = false;

        $data = func_get_args();
        echo $render->render($data);
    }

    /**
     * Gets information about one or more PHP variables and return it in HTML code
     *
     * @return string
     */
    public static function render()
    {
        self::_load_helpers();

        $render = new DumpRender();
        $render->show_caller = false;

        $data = func_get_args();
        return $render->render($data);
    }

    /**
     * Gets information about one or more PHP variables and return it in plain text
     *
     * @return string
     */
    public static function print_r()
    {
        self::_load_helpers();

        $render = new DumpRender();
        $render->html = false;
        $render->show_caller = false;

        $data = func_get_args();
        return $render->render($data);
    }

    /**
     * Gets information about one or more PHP variables and return it in HTML code.
     *
     * @param mixed $name Name of the analyzed var, or dictionary with several vars and names
     * @param mixed $value
     *
     * @return string
     */
    public static function render_data($name, $value, $show_caller = true)
    {
        self::_load_helpers();

        $render = new DumpRender();
        $render->show_caller = $show_caller;
        return $render->render($name, $value);
    }


    /**
     * Analyzes the backtrace generated by debug_backtrace function(),
     * adding contextual information.
     * The result is returned in an array with the keys:
     * 'function': function name
     * 'args': arguments name and value
     * 'file': file where the call occurs
     * 'line': line of the file where the call occurs
     * 'source': source code where the call comes (in HTML format)
     *
     * @param array $ call stack trace to be analyzed, if not use this parameter indicates the call stack before the function
     *
     * @return array
     */
    public static function backtrace(array $trace = null)
    {
        if ($trace === null) {
            $trace = debug_backtrace();
        }

        //"Special" functions
        $special_functions = array('include', 'include_once', 'require', 'require_once');

        $output = array();
        foreach ($trace as $i => $step) {
            //Get data from the current step
            foreach (array('class', 'type', 'function', 'file', 'line', 'args', 'object') as $param) {
                $$param = isset($step[$param]) ? $step[$param] : null;
            }

            //Source code of the call to this step
            if (!empty($file) && !empty($line)) {
                self::_load_helpers();
                $source = DumpRender::get_source($step['file'], $step['line']);
            } else {
                $source = '';
            }

            //Arguments
            $function_call = $class . $type . $function;
            $function_args = array();
            if (isset($args)) {
                if (in_array($function, $special_functions)) {
                    $function_args = array(self::clean_path($args[0]));
                } else {
                    if (!function_exists($function) || strpos($function, '{closure}') !== false) {
                        $params = null;
                    } else {
                        if (class_exists('ReflectionMethod', false)) {
                            if (isset($class)) {
                                $reflection = new ReflectionMethod(
                                    $class, method_exists(
                                    $class,
                                    $function
                                ) ? $function : '__call'
                                );
                            } else {
                                $reflection = new ReflectionFunction($function);
                            }
                            $params = $reflection->getParameters();
                        }
                    }

                    foreach ($args as $i => $arg) {
                        if (isset($params[$i])) {
                            // Assign the argument by the parameter name
                            $function_args[$params[$i]->name] = $arg;
                        } else {
                            // Assign the argument by number
                            $function_args[$i] = $arg;
                        }
                    }
                }
            }
            $info = array(
                'function' => $function_call,
                'args'     => $function_args,
                'file'     => self::clean_path($file),
                'line'     => $line,
                'source'   => $source,
            );

            if (isset($object)) {
                $info = array(
                            'object' => $object
                        ) + $info;
            }

            $output[] = $info;
        }
        return $output;
    }

    /**
     * Renders an abbreviated version of the backtrace
     *
     * @param array $ call stack trace to be analyzed, if not use this parameter indicates the call stack before the function
     *
     * @return string
     */
    public static function backtrace_small(array $trace = null)
    {
        if ($trace === null) {
            $trace = debug_backtrace();
        }

        $output = array();
        foreach ($trace as $i => $step) {
            //Get data from the current step
            foreach (array('class', 'type', 'function', 'file', 'line', 'args') as $param) {
                $$param = isset($step[$param]) ? $step[$param] : '';
            }

            //Generate HTML
            self::_load_helpers();
            $output[] = DumpRender::html_element('abbr', array('title' => "$file:$line"), $class . $type . $function);
        }

        return implode(' &rarr; ', array_reverse($output));
    }

    /**
     * Renders source code of an specified programming language
     *
     * @param string $code
     * @param string $language
     *
     * @return string
     */
    public static function source($code, $language = 'php', $editable = false, $attrs = array(), $theme = 'default')
    {
        self::_load_helpers();

        $code = htmlspecialchars($code, ENT_NOQUOTES);
        $extra = '';
        $tag = 'pre';
        if ($editable) {
            $extra = 'data-editable="true"';
            if (is_string($editable)) {
                $tag = "textarea name=\"$editable\"";
            } else {
                $tag = 'textarea';
            }
        }
        $extra .= DumpRender::html_attributes($attrs);
        return "<$tag class=\"dump-code\" data-language=\"$language\" data-theme=\"$theme\" $extra>$code</$tag>" .
               DumpRender::assets_loader('init_dump($(".dump-code"),{static_url:"' . self::$_static_url . '"})', self::$_static_url);
    }

    /**
     * Clean a path, replacing the special folders defined in the config. E.g.:
     *         /home/project/www/index.php -> APP_PATH/index.php
     *
     * @param string $path
     * @param bool   $restore True for restore a cleared path to its original state
     *
     * @return string
     */
    public static function clean_path($path, $restore = false)
    {
        foreach (self::$_special_paths as $clean_path => $source_path) {
            if ($restore) {
                if (strpos($path, $clean_path) === 0) {
                    $path = $source_path . substr($path, strlen($clean_path));
                    break;
                }
            } else {
                if (strpos($path, $source_path) === 0) {
                    $path = $clean_path . substr($path, strlen($source_path));
                    break;
                }
            }
        }

        return $path;
    }

}

//Define shortcuts
if (!function_exists('dump')) {

    /**
     * Echo information about the selected variable.
     * This function can be overwrited for autoload the DUMP class, e.g.:
     * @code
     * function dump() {
     *      if (!class_exists('Dump', FALSE)) {
     *          require SYS_PATH . '/vendor/Dump.php';
     *          Dump::config(...);
     *      }
     *      call_user_func_array(array('Dump', 'show'), func_get_args());
     * }
     * @endcode
     */
    function dump()
    {
        call_user_func_array(array('Dump', 'show'), func_get_args());
    }

}

if (!function_exists('dumpdie')) {

    function dumpdie()
    {
        //Clean all output buffers
        while (ob_get_clean()) {
            ;
        }

        //Dump info
        call_user_func_array('dump', func_get_args());

        //Exit
        die(1);
    }

}